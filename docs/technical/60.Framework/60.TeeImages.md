---
title: TeeImages
sidebar_position: 60
---

This project uses different tools, One of the
most important is Yocto. In the sections below we describe what it is
and other tools we use to build the image that contains our secure
application.

## Yocto Overview

It is important to bring up what is yocto before continuing:

> The Yocto project. It is not an embedded linux distribution,
> It creates a custom one for you.
>
> -- <cite>Yocto project</cite>

One of the strengths of the Yocto project is that it has an active
community of embedded enthusiasts, developers, hardware vendors and
engineers which can share configurations, software stacks and best
practices that everyone can use in order to build linux base
distributions regardless the hardware. This set of configurations,
software, hardware abstraction layers and settings are shared through
what the community knows as **recipes**.

Figuratively speaking you can think of Yocto as a chef that takes a mix of recipes to add the right ingredients and after some time cooking,
delivers you a complete linux distribution.

It is unlikely that you would have to create a recipe from the ground,
as there are plenty of recipes that allow for
customization and in general new boards comes with BSPs(Board support
packages) in the form of recipes that hardware vendors provide.
Yocto comes with other tools that take care of including the dependencies our application needs, according to the [documentation](https://www.yoctoproject.org/software-overview/), this tools are:

- **Yocto**:
  The umbrella open source project that contains a set of tools for
  building, testing, hardware decription(Device tree), licensing and
  other components for linux-base operating systems.
- **Poky**:
  It is a reference embedded distribution. In our case Poky can be seem as a full feature OS that emulates the
  one running on the target board, allowing for a secure cross-compilation that uses the target build tools.
- **OpenEmbedded**:
  The open source build engine.

### Meta-data

Yocto uses recipes, layers and configurations to allow users to modify a reference embedded
distribution like **Poky**. The union of this elements is called **meta-data**.
There is a foundational **meta-data** that linux-base distributions require and is part of OpenEmbedded-Core(oe) project.
A meta-data may look like:

```bash

├── conf/
├── COPYING.MIT
├── README
├── recipes/
├── app_recipes/
```

The meta-data is used to construct any element that would be part of the final image, it contains recipes that the build system parses to know how to compile a
package, where to get the source code, dependencies, what version
of software to use. this meta data also tells the build engine how to apply patches before compiling, how to install the software and what to do after it.

## Tee-images Overview

The entry point for building our application and the custom OS is the
[tee-images](https://github.com/Zondax/tee-images) repository, which
contains some scripts that make easy to interact with yocto, build
the images, and create development workspace for testing. It does **not** contain any yocto-base meta-data or recipes but
have the link to the [manifest](https://github.com/Zondax/tee-manifest), this manifest contains the links to the custom
meta-data we use and also meta-data provided by vendors of our supported
board(freescale and ST).
The steps the scripts follow for building an image are:

- Pull the manifest
- pull the meta-data pointed to by the manifest
- start docker
- and calls bitbake(build engine) inside the docker container to parse the meta-data
- starts compiling and building all the packages and image itself.

We can group the metadata pointed by the manifest in three parts:

- specific board meta-data:
  - [poky](https://git.yoctoproject.org/poky/): The base linux-distribution
  - [meta-freescale](https://github.com/Freescale/meta-freescale): It is a layer containing recipes to support NXP
    platforms or boards, like Device-tree-descriptors, peripherals,
    graphics and kernel drivers and so on.
  - [meta-st-stm32mp](https://github.com/STMicroelectronics/meta-st-stm32mp): The same as free-scale, it contains vendor
    recipes to support stm32mp hardware.
- Optee meta-data:
  - This metadata is part of the vendor meta-data, as it depends on
    the platform and how the vendor implements the Optee specification
    for each board.
- Zondax metadata:
  - [meta-zondax-qemu](https://github.com/Zondax/meta-zondax-qemu): Contains recipes to build the application for
    qemu this includes optee libraries.
  - [meta-zondax](https://github.com/Zondax/meta-zondax): this contains our application and some patches, as well as Rust build tools that are not installed
    on the final image but use for cross-compilation.
  - [meta-zondax_stm32mp](https://github.com/Zondax/meta-zondax-stm32mp/tree/honister): contains some patches to the optee framework
    that are applied at build time
  - [meta-zondax-imx8](https://github.com/Zondax/meta-zondax-imx8/tree/honister): contains extra packages to build the kernel that
    runs on this board, and some patches to the optee framework.
